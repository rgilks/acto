import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { type AdventureNode, AdventureChoiceSchema } from '@/lib/domain/schemas';
import { generateAdventureNodeAction } from '../actions/adventure';
import { z } from 'zod';

// Simplified History Item
export interface StoryHistoryItem {
  passage: string; // The text passage generated by AI
  choiceText?: string; // The text of the choice made *after* this passage
}

// Type for structured rate limit errors passed from the server
interface RateLimitError {
  message: string;
  resetTimestamp: number;
  apiType: 'text' | 'image' | 'tts';
}

// Type for the error state, which can be a string or a structured rate limit error
type ErrorState = string | { rateLimitError: RateLimitError } | null;

// Simplified State
interface AdventureState {
  currentNode: AdventureNode | null; // Node containing current passage, choices, image
  storyHistory: StoryHistoryItem[];
  isLoading: boolean;
  error: ErrorState; // Use the new ErrorState type

  // --- TTS State --- (Keep)
  isSpeaking: boolean;
  ttsError: string | null;
  ttsVolume: number;
  // --- End TTS State ---
}

interface AdventureActions {
  fetchAdventureNode: (choiceText?: string) => Promise<void>;
  // TTS Actions (Keep)
  stopSpeaking: () => void;
  setSpeaking: (isSpeaking: boolean) => void;
  setTTSError: (error: string | null) => void;
  setTTSVolume: (volume: number) => void;
  makeChoice: (choice: z.infer<typeof AdventureChoiceSchema>) => void;
  resetAdventure: () => void;
}

// Simplified Initial State
const initialState: AdventureState = {
  currentNode: null,
  storyHistory: [],
  isLoading: false,
  error: null,

  // --- Initial TTS State --- (Keep)
  isSpeaking: false,
  ttsError: null,
  ttsVolume: 1,
  // --- End Initial TTS State ---
};

export const useAdventureStore = create<AdventureState & AdventureActions>()(
  immer((set, get) => ({
    ...initialState,

    fetchAdventureNode: async (choiceText) => {
      set((state) => {
        state.isLoading = true;
        state.error = null;
      });

      try {
        const history = [...get().storyHistory];

        if (choiceText && history.length > 0) {
          history[history.length - 1] = {
            ...history[history.length - 1],
            choiceText: choiceText,
          };
        }

        const storyContextForAction = {
          history,
          // Temporary shim for old action signature:
          currentRoomId: 'room1', // Use valid RoomId placeholder
          playerHealth: 0, // Placeholder
          playerWounds: [], // Placeholder
          ogreHealth: 0, // Placeholder
          ogreRoomId: null, // Placeholder
          isPlayerDead: false, // Placeholder
        };

        console.log('Sending context to action:', storyContextForAction);

        const result = await generateAdventureNodeAction({ storyContext: storyContextForAction });

        if (result.rateLimitError) {
          console.warn('Rate limit hit:', result.rateLimitError);
          set((state) => {
            state.error = { rateLimitError: result.rateLimitError! };
            state.isLoading = false;
          });
          return;
        }

        if (result.error) {
          throw new Error(result.error);
        }
        if (!result.adventureNode) {
          throw new Error('No adventure node received from the server.');
        }

        const newNode = result.adventureNode;

        set((state) => {
          state.storyHistory.push({ passage: newNode.passage });
          state.currentNode = newNode;
          state.isLoading = false;
          state.error = null;
        });
      } catch (error) {
        console.error('Error fetching adventure node:', error);
        set((state) => {
          state.error = error instanceof Error ? error.message : 'Failed to fetch adventure node.';
          state.isLoading = false;
        });
      }
    },

    makeChoice: (choice: z.infer<typeof AdventureChoiceSchema>) => {
      const { isLoading, stopSpeaking } = get();
      if (isLoading) return;
      stopSpeaking();
      void get().fetchAdventureNode(choice.text);
    },

    resetAdventure: () => {
      set(initialState);
    },

    // TTS Actions (Unchanged)
    stopSpeaking: () => {
      get().setSpeaking(false);
    },
    setSpeaking: (speaking: boolean) => {
      set((state) => {
        state.isSpeaking = speaking;
        if (!speaking) {
          state.ttsError = null;
        }
      });
    },
    setTTSError: (error: string | null) => {
      set((state) => {
        state.ttsError = error;
        state.isSpeaking = false;
      });
    },
    setTTSVolume: (volume: number) => {
      const clampedVolume = Math.max(0, Math.min(1, volume));
      set((state) => {
        state.ttsVolume = clampedVolume;
      });
    },
  }))
);

export default useAdventureStore;
