import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { type AdventureNode, AdventureChoiceSchema } from '@/lib/domain/schemas';
import { generateAdventureNodeAction } from '../actions/adventure';
import { z } from 'zod';

// Simplified History Item
export interface StoryHistoryItem {
  passage: string; // The text passage generated by AI
  choiceText?: string; // The text of the choice made *after* this passage
  summary?: string;
}

// Type for structured rate limit errors passed from the server
interface RateLimitError {
  message: string;
  resetTimestamp: number;
  apiType: 'text' | 'image' | 'tts';
}

// Type for the error state, which can be a string or a structured rate limit error
type ErrorState = string | { rateLimitError: RateLimitError } | null;

// Type for the metadata to be stored and passed
interface AdventureMetadata {
  genre?: string | null;
  tone?: string | null;
  visualStyle?: string | null;
}

// Simplified State
interface AdventureState {
  currentNode: AdventureNode | null; // Node containing current passage, choices, image
  storyHistory: StoryHistoryItem[];
  isLoading: boolean;
  error: ErrorState; // Use the new ErrorState type
  currentGenre: string | null; // Store current genre
  currentTone: string | null; // Store current tone
  currentVisualStyle: string | null; // Store current visual style

  // --- TTS State --- (Keep)
  isSpeaking: boolean;
  ttsError: string | null;
  ttsVolume: number;
  // --- End TTS State ---
}

interface AdventureActions {
  fetchAdventureNode: (choiceText?: string, metadata?: AdventureMetadata) => Promise<void>;
  setCurrentMetadata: (metadata: AdventureMetadata) => void;
  // TTS Actions (Keep)
  stopSpeaking: () => void;
  setSpeaking: (isSpeaking: boolean) => void;
  setTTSError: (error: string | null) => void;
  setTTSVolume: (volume: number) => void;
  makeChoice: (choice: z.infer<typeof AdventureChoiceSchema>) => void; // Takes full choice object now
  resetAdventure: () => void;
  triggerReset: () => void;
}

// Simplified Initial State
const initialState: AdventureState = {
  currentNode: null,
  storyHistory: [],
  isLoading: false,
  error: null,
  currentGenre: null, // Initialize metadata
  currentTone: null,
  currentVisualStyle: null,

  // --- Initial TTS State --- (Keep)
  isSpeaking: false,
  ttsError: null,
  ttsVolume: 1,
  // --- End Initial TTS State ---
};

export const useAdventureStore = create<AdventureState & AdventureActions>()(
  immer((set, get) => ({
    ...initialState,

    setCurrentMetadata: (metadata) => {
      set((state) => {
        state.currentGenre = metadata.genre ?? null;
        state.currentTone = metadata.tone ?? null;
        state.currentVisualStyle = metadata.visualStyle ?? null;
      });
    },

    fetchAdventureNode: async (choiceText, metadata) => {
      set((state) => {
        state.isLoading = true;
        state.error = null;
      });

      try {
        const currentHistory = get().storyHistory; // Get current history
        const isInitialCall = currentHistory.length === 0;

        // Prepare history for the action call
        const historyForAction = [...currentHistory];
        if (choiceText && !isInitialCall) {
          // Add choice text to the *last* passage in the history we send
          historyForAction[historyForAction.length - 1] = {
            ...historyForAction[historyForAction.length - 1],
            choiceText: choiceText,
          };
        }

        const storyContextForAction = {
          history: historyForAction,
        };

        // Determine metadata to send
        let metadataToSend: AdventureMetadata = {};
        if (isInitialCall && metadata) {
          // If first call, use provided metadata and store it
          get().setCurrentMetadata(metadata); // Store the metadata
          metadataToSend = metadata;
          console.log('Initial call. Storing and sending metadata:', metadata);
        } else if (!isInitialCall) {
          // For subsequent calls, retrieve stored metadata
          metadataToSend = {
            genre: get().currentGenre,
            tone: get().currentTone,
            visualStyle: get().currentVisualStyle,
          };
          console.log('Subsequent call. Sending stored metadata:', metadataToSend);
        }

        // Prepare parameters for the action
        const actionParams: Parameters<typeof generateAdventureNodeAction>[0] = {
          storyContext: storyContextForAction,
          genre: metadataToSend.genre ?? undefined,
          tone: metadataToSend.tone ?? undefined,
          visualStyle: metadataToSend.visualStyle ?? undefined,
        };

        // Add initial scenario text only on the first call
        if (isInitialCall && choiceText) {
          actionParams.initialScenarioText = choiceText;
          console.log('Sending initial scenario text to action:', choiceText);
        } else if (!isInitialCall) {
          console.log('Sending context to action:', storyContextForAction);
        }

        const result = await generateAdventureNodeAction(actionParams);

        if (result.rateLimitError) {
          console.warn('Rate limit hit:', result.rateLimitError);
          set((state) => {
            state.error = { rateLimitError: result.rateLimitError! };
            state.isLoading = false;
          });
          return;
        }

        if (result.error) {
          throw new Error(result.error);
        }
        if (!result.adventureNode) {
          throw new Error('No adventure node received from the server.');
        }

        const newNode = result.adventureNode;

        // Always push the new node's passage to the history
        set((state) => {
          // Store the new passage, along with its summary (if provided by AI)
          // The choiceText for *this* new passage will be added on the *next* call
          state.storyHistory.push({ passage: newNode.passage, summary: newNode.updatedSummary });
          state.currentNode = newNode;
          state.isLoading = false;
          state.error = null;
        });
      } catch (error) {
        const errorMessage =
          error instanceof Error ? error.message : 'Failed to fetch adventure node.';
        if (errorMessage === 'Unauthorized: User must be logged in.') {
          console.info('[Adventure Store] Unauthorized: User must be logged in.'); // Log as info
        } else {
          console.error('Error fetching adventure node:', error); // Log other errors as error
        }
        set((state) => {
          state.error = errorMessage;
          state.isLoading = false;
        });
      }
    },

    makeChoice: (choice) => {
      // Expects the full choice object
      const { isLoading, stopSpeaking, storyHistory } = get();
      if (isLoading) return;
      stopSpeaking();

      const isInitialChoice = storyHistory.length === 0;
      let metadataToPass: AdventureMetadata | undefined = undefined;

      if (isInitialChoice) {
        // Extract metadata from the initial scenario choice
        metadataToPass = {
          genre: choice.genre,
          tone: choice.tone,
          visualStyle: choice.visualStyle,
        };
      }

      // Call fetchAdventureNode, passing choice text and metadata (if initial)
      void get().fetchAdventureNode(choice.text, metadataToPass);
    },

    resetAdventure: () => {
      // Keep the current TTS volume when resetting
      const currentVolume = get().ttsVolume;
      set({ ...initialState, ttsVolume: currentVolume });
    },

    triggerReset: () => {
      const { resetAdventure } = get();
      resetAdventure(); // Call the existing reset logic
      // Clear the scenario cache from session storage
      if (typeof window !== 'undefined') {
        try {
          sessionStorage.removeItem('adventureGame_startingScenarios');
          console.log('[Store] Cleared scenario cache.');
        } catch (error) {
          console.error('[Store] Error clearing scenario cache from sessionStorage:', error);
        }
      }
    },

    // TTS Actions (Unchanged)
    stopSpeaking: () => {
      get().setSpeaking(false);
    },
    setSpeaking: (speaking: boolean) => {
      set((state) => {
        state.isSpeaking = speaking;
        if (!speaking) {
          state.ttsError = null;
        }
      });
    },
    setTTSError: (error: string | null) => {
      set((state) => {
        state.ttsError = error;
        state.isSpeaking = false;
      });
    },
    setTTSVolume: (volume: number) => {
      const clampedVolume = Math.max(0, Math.min(1, volume));
      set((state) => {
        state.ttsVolume = clampedVolume;
      });
    },
  }))
);

export default useAdventureStore;
