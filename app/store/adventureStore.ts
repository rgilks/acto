import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import { type AdventureNode, AdventureChoiceSchema } from '@/lib/domain/schemas';
import { generateAdventureNodeAction } from '../actions/adventure';
import { z } from 'zod';

// Simplified History Item
export interface StoryHistoryItem {
  passage: string; // The text passage generated by AI
  choiceText?: string; // The text of the choice made *after* this passage
}

// Simplified State
interface AdventureState {
  currentNode: AdventureNode | null; // Node containing current passage, choices, image
  storyHistory: StoryHistoryItem[];
  isLoading: boolean;
  error: string | null;
  // -- Removed Fields --
  // currentRoomId: RoomId | null;
  // currentImagePlaceholder: string | null; // Maybe keep if useful for loading?
  // playerHealth: number;
  // playerWounds: string[];
  // ogreHealth: number;
  // ogreRoomId: RoomId | null;
  // isPlayerDead: boolean;
  // isOgreDefeated: boolean;
  // -- End Removed Fields --

  // --- TTS State --- (Keep)
  isSpeaking: boolean;
  ttsError: string | null;
  ttsVolume: number;
  // --- End TTS State ---
}

interface AdventureActions {
  // fetchAdventureNode now only needs optional choiceText
  fetchAdventureNode: (choiceText?: string) => Promise<void>;
  // TTS Actions (Keep)
  stopSpeaking: () => void;
  setSpeaking: (isSpeaking: boolean) => void;
  setTTSError: (error: string | null) => void;
  setTTSVolume: (volume: number) => void;
  // makeChoice now takes simplified choice
  makeChoice: (choice: z.infer<typeof AdventureChoiceSchema>) => void;
  // resetAdventure resets to initial state (no automatic fetch)
  resetAdventure: () => void;
  // NEW action placeholder for starting scenarios
  // fetchStartingScenarios: () => Promise<void>; // We'll add this later
}

// Simplified Initial State
const initialState: AdventureState = {
  currentNode: null,
  storyHistory: [],
  isLoading: false,
  error: null,
  // -- Removed Fields --
  // currentRoomId: null,
  // currentImagePlaceholder: null,
  // playerHealth: 10,
  // playerWounds: [],
  // ogreHealth: 20,
  // ogreRoomId: 'room5',
  // isPlayerDead: false,
  // isOgreDefeated: false,
  // -- End Removed Fields --

  // --- Initial TTS State --- (Keep)
  isSpeaking: false,
  ttsError: null,
  ttsVolume: 1,
  // --- End Initial TTS State ---
};

export const useAdventureStore = create<AdventureState & AdventureActions>()(
  immer((set, get) => ({
    ...initialState,

    fetchAdventureNode: async (choiceText) => {
      set((state) => {
        state.isLoading = true;
        state.error = null;
      });

      try {
        // Get current history
        const history = [...get().storyHistory];

        // If a choice was made, add it to the *last* history item
        if (choiceText && history.length > 0) {
          history[history.length - 1] = {
            ...history[history.length - 1],
            choiceText: choiceText,
          };
        }

        // Prepare context for the backend (only history is needed now)
        const storyContextForAction = {
          history,
          // Temporary shim for old action signature:
          currentRoomId: 'room1', // Use valid RoomId placeholder
          playerHealth: 0, // Placeholder
          playerWounds: [], // Placeholder
          ogreHealth: 0, // Placeholder
          ogreRoomId: null, // Placeholder
          isPlayerDead: false, // Placeholder
        };

        console.log('Sending context to action:', storyContextForAction);

        // Call the backend action (remove temporary 'as any')
        const result = await generateAdventureNodeAction({ storyContext: storyContextForAction });

        if (result.error) {
          throw new Error(result.error);
        }
        // Backend action should return simplified AdventureNode
        if (!result.adventureNode) {
          throw new Error('No adventure node received from the server.');
        }

        const newNode = result.adventureNode;

        set((state) => {
          // Add the *new* passage to history (choiceText will be added on next turn)
          state.storyHistory.push({ passage: newNode.passage });
          state.currentNode = newNode;
          state.isLoading = false;
          state.error = null;
          // Remove updates for combat/room state
        });
      } catch (error) {
        console.error('Error fetching adventure node:', error);
        set((state) => {
          state.error = error instanceof Error ? error.message : 'Failed to fetch adventure node.';
          state.isLoading = false;
        });
      }
    },

    makeChoice: (choice: z.infer<typeof AdventureChoiceSchema>) => {
      // Removed isPlayerDead check
      const { isLoading, stopSpeaking } = get();

      if (isLoading) {
        console.log('Cannot make choice while loading.');
        return;
      }
      stopSpeaking();
      // Call fetchAdventureNode with the chosen text
      void get().fetchAdventureNode(choice.text);
    },

    resetAdventure: () => {
      // Reset to initial state, don't fetch automatically
      set(initialState);
    },

    // TTS Actions (Unchanged)
    stopSpeaking: () => {
      get().setSpeaking(false);
    },
    setSpeaking: (speaking: boolean) => {
      set((state) => {
        state.isSpeaking = speaking;
        if (!speaking) {
          state.ttsError = null;
        }
      });
    },
    setTTSError: (error: string | null) => {
      set((state) => {
        state.ttsError = error;
        state.isSpeaking = false;
      });
    },
    setTTSVolume: (volume: number) => {
      const clampedVolume = Math.max(0, Math.min(1, volume));
      set((state) => {
        state.ttsVolume = clampedVolume;
      });
    },
  }))
);

export default useAdventureStore;
